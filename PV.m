% This implements a phase vocoder for time-stretching/compression% Put the file name of the input file in "infile"%     the file to be created is "outfile"% The amount of time-stretch is determined by the ratio of the hopin% and hopout variables. For example, hopin=242 and hopout=161.3333% (integers are not required) increases the tempo by % hopin/hopout = 1.5. To slow down a comparable amount,% choose hopin = 161.3333, hopout = 242.% 5/2005 Bill Sethares    clear; clf    infile='yoursound.wav';    outfile='yoursongchanged_12122014_50.wav';    %A = changed line 37 to for k=1:lenseg    %B = changed line 37 to for k=1:lenseg-1     %C = removed anything with time and hardcoded in 100000    %E = did stuff to test python vs matlab . . . not sure what changed/why    %it seems to be the same at this stage    %time=0;                                    % total time to process    hopin=242;                                 % hop length for input     hopout=161.3333;                                % hop length for output    all2pi=2*pi*(0:100);                       % all multiples of 2 pi (used in PV-style freq search)     max_peak=50;                               % parameters for peak finding: number of peaks    eps_peak=0.005;                            % height of peaks    nfft=2^12; nfft2=nfft/2;                   % fft length     win=hanning(nfft)';                        % windows and windowing variables            [y,sr]=wavread(infile);                    % read song file    siz=wavread(infile,'size');                % length of song in samples    stmo=min(siz); leny=max(siz);              % stereo (stmo=2) or mono (stmo=1)    if siz(2)<siz(1), y=y'; end    %if time==0, time = 100000; end    tt=zeros(stmo,ceil(hopout/hopin)*min(leny,100000*sr)); % place for output where time = 100000    lenseg=floor((min(leny,100000*sr)-nfft)/hopin); % number of nfft segments to process    ssf=sr*(0:nfft2)/nfft;                     % frequency vector    old_phase=zeros(stmo,nfft2+1); phadvance=zeros(stmo,nfft2+1);    outbeat=zeros(stmo,nfft); pold1=[]; pold2=[];    dtin=hopin/sr;                             % time advances dt per hop for input    dtout=hopout/sr;                           % time advances dt per hop for output        for k=0:lenseg-1                          % main loop - process each beat separately %changed from k=1:LENSEG-1 for D        %if k/1000==round(k/1000), disp(k), end % for display so I know where we are        indin=round(((k)*hopin+1):((k)*hopin+nfft)); %CHANGED FROM K-1 to K and removed +1 to hopout for D        for sk=1:stmo                          % do L/R channels separately            segment=win.*y(sk,indin);                % get this frame and take FFT            %plot(y(sk,indin));            %plot(segment);                        ffts=fft(segment);            spectrum_magnitude=abs(ffts(1:nfft2+1));             spectrum_phase=angle(ffts(1:nfft2+1));                        % find peaks to define spectral mapping            peaks=findPeaks4(spectrum_magnitude, max_peak, eps_peak, ssf); %ssf not used here            %plot(peaks);             [dummy,inds]=sort(spectrum_magnitude(peaks(:,2)));                        peaksort=peaks(inds,:);            peak_values=peaksort(:,2);                        %peak_values = spectrum(peaks(:,2));            %plot(spectrum);            %hold on;            %plot(peaks(:,2),peak_values, 'o');            %clf;                           freq_estimates=zeros(size(peak_values));            for tk=1:length(peak_values)                % estimate frequency using PV strategy                  dtheta=(spectrum_phase(peak_values(tk))-old_phase(sk,peak_values(tk)))+all2pi;                fest=dtheta./(2*pi*dtin);      % see pvanalysis.m for same idea                [er,indf]=min(abs(ssf(peak_values(tk))-fest)); %gets the min of the possible frequency estimates                freq_estimates(tk)=fest(indf);          % find best freq estimate for each row            end                        %plot(freq_estimates); %discrepency with python exists here 12112014 0616            %discrepancy solved! 12122014 0620 was a copy error            % generate output spectrum and phase             spectrumout=spectrum_magnitude; phout=spectrum_phase;            for tk=1:length(peak_values)                fdes=freq_estimates(tk);                           % reconstruct with original frequency                freqind=(peaksort(tk,1):peaksort(tk,3));  % indices of the surrounding bins                                % specify magnitude and phase of each partial                spectrumout(freqind)=spectrum_magnitude(freqind);                phadvance(sk,peaksort(tk,2))=phadvance(sk,peaksort(tk,2))+2*pi*fdes*dtout;                pizero=pi*ones(1,length(freqind));                pcent=peaksort(tk,2)-peaksort(tk,1)+1;                indpc=(2-mod(pcent,2)):2:length(freqind); %start:step:end                pizero(indpc)=zeros(1,length(indpc));                phout(freqind)=phadvance(sk,peaksort(tk,2))+pizero;            end            % reconstruct time signal (stretched or compressed)            %PYTHON WORKS THE SAME (more or less) UP TO HERE 1292014 6:01            compl=spectrumout.*exp(sqrt(-1)*phout);            %plot(spectrumout);            compl(nfft2+1)=ffts(nfft2+1);            test_val = conj(compl(2:(nfft2)));            compl=[compl,fliplr(test_val)]; %concats             wave=real(ifft(compl));            outbeat(sk,:)=wave;            old_phase(sk,:)=spectrum_phase;                     end % end stereo        indout=round(((k)*hopout+1):((k)*hopout+nfft)); %CHANGED FROM K-1 to K and removed +1 to hopout for D        tt(:,indout)=tt(:,indout)+outbeat;    end    abstt = abs(tt);    maxabstt = max(abstt);    maxmax = max(maxabstt);    tt=0.8*tt/(max(abs(tt)));    [rtt,ctt]=size(tt); %   rows and columns, NOT real and complex     if rtt==2       tt=tt';     end    subplot(3,2,1), plot(y(sk,indin)), title('Original');    subplot(3,2,2), plot(win), title('Window');    subplot(3,2,4), plot(spectrum_magnitude), title('Spectrum Magnitude');    subplot(3,2,5), plot(spectrum_phase), title('Spectrum Phase');    subplot(3,2,3), plot(segment), title('Segment');    subplot(3,2,6), plot(tt(sk,indout)), title('Altered');    wavwrite(tt,sr,16,outfile);    fclose('all');        %PYTHON WORKS THE SAME (more or less) UP TO HERE 12102014   0316   